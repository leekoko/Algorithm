# Lanqiaobei
算法知识的收集

1.年龄巧合

    小明和他的表弟一起去看电影，有人问他们的年龄。小明说：今年是我们的幸运年啊。我出生年份的四位数字加起来刚好是我的年龄。表弟的也是如此。已知今年是2014年，并且，小明说的年龄指的是周岁。

    请推断并填写出小明的出生年份。
题目分析：
1.周岁出生的时候为0岁，不用加1
下次完成：5min
答案：1988

2.好好学习
    汤姆跟爷爷来中国旅游。一天，他帮助中国的小朋友贴标语。他负责贴的标语是分别写在四块红纸上的四个大字：“好、好、学、习”。但是汤姆不认识汉字，他就想胡乱地贴成一行。
    请你替小汤姆算一下，他这样乱贴，恰好贴对的概率是多少？
    答案是一个分数，请表示为两个整数比值的形式。例如：1/3 或 2/15 等。
如果能够约分，请输出约分后的结果。
题目分析：
1.全排列的个数减去重复的部分
太难做，以后完成

3.找出所有1~100内的素数
题目分析：
1.数字2是素数，1规定不是素数，判断素数的时候需要区别出来
下次完成：5min

3.埃及分数
    古埃及曾经创造出灿烂的人类文明，他们的分数表示却很令人不解。古埃及喜欢把一个分数分解为类似： 1/a + 1/b 的格式。
    这里，a 和 b 必须是不同的两个整数，分子必须为 1
    比如，2/15 一共有 4 种不同的分解法（姑且称为埃及分解法）：
1/8 + 1/120
1/9 + 1/45
1/10 + 1/30
1/12 + 1/20
    那么， 2/45 一共有多少个不同的埃及分解呢（满足加法交换律的算同种分解）？ 请直接提交该整数（千万不要提交详细的分解式！）。
题目分析：
1.分析两个分数必须是：一个小于45，一个大于45.因为如果两个都小于，那么相加就大于那个得数。如果两个都大于，想加就小于那个得数。既然知道一个大于一个小于，那么数的数的开始就可以确定。可是第二个数的结束怎么确定呢？这应该是一个趋势的数，当达到一定的数量就不会再符合条件
2.当拿到两个数的分母之后根据其交叉相乘与得数对比的结果，符合的话就计数++
下次完成：5min

4.出栈次序
    X星球特别讲究秩序，所有道路都是单行线。一个甲壳虫车队，共16辆车，按照编号先后发车，夹在其它车流中，缓缓前行。
    路边有个死胡同，只能容一辆车通过，是临时的检查站，如图【p1.png】所示。
    X星球太死板，要求每辆路过的车必须进入检查站，也可能不检查就放行，也可能仔细检查。
    如果车辆进入检查站和离开的次序可以任意交错。那么，该车队再次上路后，可能的次序有多少种？
    为了方便起见，假设检查站可容纳任意数量的汽车。
    显然，如果车队只有1辆车，可能次序1种；2辆车可能次序2种；3辆车可能次序5种。
    现在足足有16辆车啊，亲！需要你计算出可能次序的数目。
    这是一个整数，请通过浏览器提交答案，不要填写任何多余的内容（比如说明性文字）。
题目分析：
1.这种解法叫做：catalan数
太难做，以后完成

5.金蝉素数
    考古发现某古墓石碑上刻着一个数字：13597，后研究发现：
    这是一个素数！
    并且，去掉首尾数字仍是素数！
    并且，最中间的数字也是素数！
    这样特征的数字还有哪些呢？通过以下程序的帮助可以轻松解决。请仔细阅读代码，并填写划线部分缺失的代码。

public class A
{
    static boolean isPrime(int n)
    {
        if(n<=1) return false;
        for(int i=2; i*i<=n; i++){
            if(n%i==0) return false;
        }
        return true;
    }

    static void f(int[] x, int k)
    {
        if(_____________________________){  // 填空位置
            if(isPrime(x[0]*10000 + x[1]*1000 + x[2]*100 + x[3]*10 + x[4]) &&
                isPrime(x[1]*100 + x[2]*10 + x[3]) &&
                isPrime(x[2]))
                System.out.println(""+x[0]+x[1]+x[2]+x[3]+x[4]);
            return;
        }

        for(int i=k; i<x.length; i++){
            {int tmp=x[k]; x[k]=x[i]; x[i]=tmp; }
            f(x,k+1);
            {int tmp=x[k]; x[k]=x[i]; x[i]=tmp; }
        }
    }

    static void test()
    {
        int[] x = {1,3,5,7,9};
        f(x,0);
    }

    public static void main(String[] args)
    {
        test();
    }
}
题目分析：
1.看以下代码部分，会发现这是一道回溯的题目。那么可以猜测这是一道全排列再筛选的题目，全排列的方式就是，将i从0开始赋值，后面再进行回溯。
        for(int i=k; i<x.length; i++){
            {int tmp=x[k]; x[k]=x[i]; x[i]=tmp; }
            f(x,k+1);
            {int tmp=x[k]; x[k]=x[i]; x[i]=tmp; }
        }
2.所以进一步可以猜测其if部分就是递归的节点，根据k的递增，其节点应该就是数组的最大数。即  x.length-1
答案：k==x.length-1
